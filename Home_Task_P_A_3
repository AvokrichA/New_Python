## Условие 1: 
### 1 задача
Считать данные с помощью pandas
Вывести на экран первые 5 строк
- id - Уникальный ID для каждого дома
- date - Дата продажи дома
- price - Стоимость продажи дома
- bedrooms - Кол-во спален
- bathrooms - Кол-во ванных комнат (0.5 - туалет без душа)
- sqft_living - Кв. метры жилые
- sqft_lot - Кв. метры общие
- floors - Кол-во этажей
- waterfront - Есть набержная или нет
- view - Значение от 0 до 4 насколько хороший вид
- condition - Значение от 1 до 5 насколько хорошее состояние
- grade - Значение от 1 до 13, где 1-3 плохая конструкция здания и дизайн, 7 - средний уровень конструкции и дизайна, 11-13 - высокое качество конструкции и дизайна
- sqft_above - Кв. метры дома, которые находятся выше земли
- sqft_basement - Кв. метры дома, которые находятся ниже земли
- yr_built - Год постройки дома
- yr_renovated - Год ремонта дома
- zipcode - Индекс
- lat - Широтма
- long - Долгота
- sqft_living15 - Кв. метры жилой площади у 15 соседей
- sqft_lot15 - Кв. метры общей площади у 15 соседей

import pandas as pd

df = pd.read_csv('C:\\Users\\Pobeda\\Desktop\\geekbrains\\Python_для_аналитиков\\kc-house-data.csv')
df.head()

### 1.2 Создать новый признак delta_renovated,
который будет содержать разницу в годах между годом реновацией дома и годом постройки дома
Если реновации дома не было, то в новом признаке поставьте 0


df['delta_renovated'] = df['yr_built'] - df['yr_renovated']
df[df['delta_renovated']<0] = 0
df.head()

df.columns

### 1.3 Создайте признаки года продажи, месяца продажи

df['yr_sale'] = 0
df['month_sale'] = 0
df.head()


### 1.4 Удалите признаки date, zipcode, lat, long

df.drop( columns = ['date', 'zipcode', 'lat', 'long'], inplace = True)
df.head()


## Условие 2: 
### 2 задача
Создайте датафрейм с клиентами:
clients = pd.DataFrame({
'client_id': [1459, 4684, 3498, 3942, 4535, 2308, 2866, 2765, 1472, 4236, 2295,
939, 3840, 280, 20, 4332, 3475, 4213, 3113, 4809, 2134, 2242,
2068, 4929, 1384, 1589, 3317, 2260, 1727, 1764, 1611, 1474],
'house_id': [8965450190, 6823100225, 5104540330, 2131701075, 1522700060,
1189000207, 6821600300, 7137950720, 9510920050, 6131600255,
5428000070, 1788800910, 8100400160, 3123049142, 6306800010,
5083000375, 7920100025, 1951600150, 809001400, 339600110,
1622049154, 1099600250, 8563000110, 2768100205, 3995700435,
8861700030, 3303980210, 7731100066, 8146100580, 825069097,
3889100029, 9524100196]
})

clients = pd.DataFrame({ 'client_id': [1459, 4684, 3498, 3942, 4535, 2308, 2866, 2765, 1472, 4236, 2295, 939, 3840, 280, 20, 4332, 3475, 4213, 3113, 4809, 2134, 2242, 2068, 4929, 1384, 1589, 3317, 2260, 1727, 1764, 1611, 1474], 'house_id': [8965450190, 6823100225, 5104540330, 2131701075, 1522700060, 1189000207, 6821600300, 7137950720, 9510920050, 6131600255, 5428000070, 1788800910, 8100400160, 3123049142, 6306800010, 5083000375, 7920100025, 1951600150, 809001400, 339600110, 1622049154, 1099600250, 8563000110, 2768100205, 3995700435, 8861700030, 3303980210, 7731100066, 8146100580, 825069097, 3889100029, 9524100196] })
clients

### 2.1 Присоедините к таблице clients данные по домам через метод join

df_id = df.set_index('id')
df_id.head()

clients_id = clients.set_index('house_id')
clients_id.head()

clients_id.join(df_id)

### 2.2 Присоедините к таблице clients данные по домам через метод merge
Это нужно, чтобы понимать, какие дома покупались клиентами
house_id - это индексы датафрейма с домами

##### Метод merge
С помощью метода merge() можно объединить две таблицы по столбцам. У первого датафрейма вызываем метод merge() и в него передаем:
* второй датафрейм
* столбец с левого датафрейма (он же первый), по которому нужно объединение (аргумент left_on)
* столбец с правого датафрейма (он же второй), по которому нужно объединение (аргумент right_on) 

merged = clients.merge(df, left_on='house_id', right_on = 'id')
merged

## Условие 3: 
### 3 задача
Составьте несколько сводных таблиц

#### 3.1 Найдите среднюю стоимость домов в зависимости от количества спален
Отсортируйте от меньшей стоимости к большей

pd.pivot_table(merged,
               index=['house_id', 'price', 'bedrooms'])

pd.pivot_table(merged,
               index=['bedrooms'],
               values = ['price'],
               aggfunc=[np.mean, len])


pd.pivot_table(merged,
               index=['bedrooms'],
               values = ['price'],).sort_values('price', ascending=True)

#### 3.2 Найдите минимальную, среднюю и максимальную стоимости домов в зависимости от состояния дома

pd.pivot_table(merged,
               index=['condition'],
               values = ['price'],
               aggfunc=[np.min, np.mean, np.max, len])


#### 3.3 Постройте таблицу с подсчетом количества домов в данных в зависимости от вида на набережную и оценкой вида

pd.pivot_table(merged,
               index=['waterfront', 'view'],
               values = ['house_id'],
               aggfunc=[len])

#### 3.4 Каких домов в зависимости от этажности и количества спален больше?

pd.pivot_table(merged,
               index=['floors', 'bedrooms'],
               values = ['house_id'],
               aggfunc=[len])

Ответ: больше всего одноэтажных домов с 3 спальнями. 

#### 3.5 Постройте таблицу с подсчетом медианной стоимости домов в данных в зависимости от состояния дома и оценки дома

pd.pivot_table(merged,
               index=['condition', 'grade'],
               values = ['price'],
               aggfunc=[np.median, len])

